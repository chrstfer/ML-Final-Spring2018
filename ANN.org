# -*- org-confirm-babel-evaluate: nil; -*-
#+AUTHOR: Chris Carrigan Brolly
#+TITLE: Artificial Neural Nets 
#+HTML_HEAD: <link href="http://gongzhitaao.org/orgcss/org.css" rel="stylesheet" type="text/css" />
#+PROPERTY: header-args :session ANNimpl

* Setup
** R Setup  
*** Libraries
#+BEGIN_SRC R :results none
library(sigmoid)
#+END_SRC
*** Functions
  #+BEGIN_SRC R :results none :export source
    getLabels <- function(lbldb, nget=0) {
	magic  <- readBin(lbldb, what="integer", n=1, endian="big", size=4)
	if(magic != 2049)
	    return(NULL)
	n.lbls    <- readBin(lbldb, what="integer", n=1,    endian="big", size=4)
	if(nget==0)
	    nget=n.lbls

	labels <- readBin(lbldb, what="integer", n=nget, endian="big",  size=1)

	close(lbldb)
	return(labels)
    }

    getImages <- function(imgdb, nget=0, progress=FALSE) {
	magic  <- readBin(imgdb, what="integer", n=1, endian="big", size=4)
	## if(magic != 2049)
	##     return(NULL)

	n.imgs <- readBin(imgdb, what="integer", n=1, endian="big", size=4)
	if(nget==0)
	    nget <- n.imgs # trunc(sqrt(n.imgs))

	n.rows <- readBin(imgdb, what="integer", n=1, endian="big", size=4)
	n.cols <- readBin(imgdb, what="integer", n=1, endian="big", size=4)

	print(gettextf("Getting %d %dx%d Images", nget, n.rows, n.cols))

	images <- c()
	for(i in 1:nget) {
	    .img   <- matrix(readBin(imgdb, what="integer", n=n.rows*n.cols, endian="big", size=1), nrow=n.rows, ncol=n.cols)
	    images <-  c(images, list(.img))
	    if(progress && i %% trunc(sqrt(nget)) == 0) 
		print(gettextf("%2.2f%%", round((100*i)/nget, digits=2)))
	}
	close(imgdb)
	return(images)
    }
  #+END_SRC



** Data Setup
*** Data (Links)
  |---------------------+----------+-------------------------------------------------------------|
  | ID                  | size (b) | Link                                                        |
  |---------------------+----------+-------------------------------------------------------------|
  | training set images |  9912422 | http://yann.lecun.com/exdb/mnist/train-images-idx3-ubyte.gz |
  | training set labels |    28881 | http://yann.lecun.com/exdb/mnist/train-labels-idx1-ubyte.gz |
  | test set images     |  1648877 | http://yann.lecun.com/exdb/mnist/t10k-images-idx3-ubyte.gz  |
  | test set labels     |     4542 | http://yann.lecun.com/exdb/mnist/t10k-labels-idx1-ubyte.gz  |
  |---------------------+----------+-------------------------------------------------------------|

*** Data (import)
  tr.files.imgs <- "datasets/training/images"
  tr.files.lbls <- "datasets/training/labels"
  ts.files.imgs <- "datasets/testing/images"
  ts.files.lbls <- "datasets/testing/labels" 


#+BEGIN_SRC R :results output graphics :file imgs/setup/ex1.png
  ## Works
  tr.labels <- as.vector(getLabels(gzfile("datasets/training/labels", "rb"), nget=256))
  tr.images <- getImages(gzfile("datasets/training/images", # data's filename
				"rb"), # read it as binary
			 ## Get 256 of the entries
			 nget=256, progress=TRUE)
  tr.im.matrix <- do.call("rbind", # create rows out of the input data
			  lapply(tr.images, as.vector)) # transform each image
							# matrix into a vector

  tr.df <- cbind(tr.im.matrix, tr.labels) # now create a data frame

  oldpar <- par(mar=rep(0,4))
  image(tr.images[[8]], useRaster=TRUE, col=seq(2^8)) 
  par(oldpar)

#+END_SRC

#+RESULTS:
[[file:imgs/setup/ex1.png]]


#+BEGIN_SRC R :results table drawer :colnames yes
  table(Labels=tr.df[,ncol(tr.df)])
  ## sprintf("Row x Col: %d x %d", nrow(tr.df), ncol(tr.df))
#+END_SRC

#+RESULTS:
:RESULTS:
| Labels | Freq |
|--------+------|
|      0 |   30 |
|      1 |   35 |
|      2 |   25 |
|      3 |   30 |
|      4 |   24 |
|      5 |   17 |
|      6 |   24 |
|      7 |   26 |
|      8 |   19 |
|      9 |   26 |
:END:


* Implementation: Multilayer Perceptron with Backprop
  - TODO ::
    - function to apply an input and get an output
      - function to run layer
      - 
** Layers Class
#+BEGIN_SRC R 
  ##
  ## WX = A
  ##

  summary.layers <- function(layers) {
      lapply(X=layers, summary)
  }

  layers.gen.layers <- function(n=4, lengths, out.classes, in.length=784) {

      layers.gen.layer <- function(n.in, n.out) {
	  .weights <- matrix(data=rnorm(n.in*n.out),
			     ncol=n.in,
			     nrow=n.out)
	  .nodes <- matrix(nrow=n.out,
			   ncol=1)
	  layer <- list()
	  layer$nodes <- .nodes
	  layer$weights <- .weights
	  class(layer) <- "layer"
	  return(layer)
      }

      layers.gen.hlayer <- function(in.layer) {
	  n.out <- lengths[in.layer]
	  if(in.layer == 1) {
	      n.in <- in.length
	  }
	  else {
	      n.in <- lengths[in.layer-1]
	  }

	  hlayer <- layers.gen.layer(n.in, n.out)                                          

	  return(hlayer)
      }

      layers.gen.olayer <- function(n.out=0, classes=as.factor(1:10)) {
	  if(n.out == 0)
	      n.out = length(classes)
	  n.in <- lengths[length(lengths)]
	  .olayer <- layers.gen.layer(n.in, n.out)
	  class(.olayer) <- "olayer"
	  oclass <- class(.olayer)
	  inherits(.olayer, oclass)
      }

      model <- list()
      model$hlayers <- lapply(X=1:n, layers.gen.hlayer)
      model$olayer <- layers.gen.olayer(n.out=length(out.classes), classes=out.classes)
      return(model)
  }

  layers.do_layer <- function(layer, input, sig=sigmoid) {
      typeof(layer$weights)
      typeof(input)
      prod <- layer$weights %*% input
      ## print(layer$nodes)

      ## ret <- list()
      ## ret$weights <- layer$weights
      ## ret$nodes <- sig(prod)
      ## class(ret) <- "layer"
      ## return(ret)
      return(sig(prod))
  }

  ann.gen_model <- function(n=4, in.length=784,
				  lengths=c(5, 4, 4, 4, 10),
			    out.classes=as.factor(1:10),
			    data) {
      ## todo: make gen.layers return a layers object with all, then we can split
      ## here and keep raw?
      model <- layers.gen.hidden(n=4, in.length=784,
				 lengths=c(5, 4, 4, 4, 10),
				 out.classes=as.factor(1:10))
      class(model) <- "model.ann"
      return(model)
  }

  ## basic layout, 4 layers of 5x1 
  model <- ann.gen_model(n=4, in.length=784,
			 lengths=c(5, 4, 4, 4, 10),
			 out.classes=as.factor(1:10),
			 data=tr.df[1,-ncol(tr.df)])
  len <- length(model$hlayers)
  mids <- numeric(len+1)

  input  <- model$input
  mids[1] <- input

  for(k in 1:len) {
      mids[k+1]  <- layers.do_layer(model$hlayers[[k]], mids[k])
  }

  output <- layers.do_layer(model$olayer, mids[len])
#+END_SRC

#+RESULTS:
| 0.219679210159256 |
| 0.447156772638455 |
| 0.927703446173608 |
| 0.517365026865628 |

** Model


* Analysis
#+BEGIN_SRC R
 
#+END_SRC

* Conclusion



* Sources
** Biblio
   These I read in the process of completing this project. In places where
   specific citations could be made, I have places them and linked here. 

- https://journal.r-project.org/archive/2010-1/RJournal_2010-1_Guenther+Fritsch.pdf
- https://en.wikipedia.org/wiki/Perceptron
- https://cran.r-project.org/web/packages/sigmoid/sigmoid.pdf
